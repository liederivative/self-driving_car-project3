import numpy as np
import pandas as pd
import tqdm
from skimage import exposure
from scipy import ndimage
import json
import cv2

########################################################
#           Helper functions                          #
#######################################################

#Constants definition
CSV_FILE_NAME = 'driving_log.csv'
OFFSET_ANG = 0.3

# ======================== Streaming transformation ===========================
def live_transformation(image,size):
    ''' tranformation for streaming in simulator (see drive.py)
    '''
    image = cv2.cvtColor(image[0], cv2.COLOR_RGB2HSV)[60:,:,1]
    image = resize(image,size[:-1][::-1]).reshape(1,size[0],size[1],size[2])

    return image
    
#==================== Preprocess : functions for loadin data ==================
def split_info(csv_file):
    ''' Helper function to return angles and images from csv file.
    '''
    return np.array(csv_file['steering']),np.array(csv_file['left']),\
            np.array(csv_file['right']),np.array(csv_file['center'])

def read_images(data):
    ''' read images from path.
        input: array with paths of [left,right,center] images
        output: dictionary with images
    '''
    return_value ={'left':[ ndimage.imread( img) for img in tqdm.tqdm(data[0])],
                   'right':[ ndimage.imread( img) for img in tqdm.tqdm(data[1])],
                   'center':[ ndimage.imread( img) for img in tqdm.tqdm(data[2])]}
    return return_value

def read_images_from_file(csv_file=CSV_FILE_NAME,new=0):
    ''' Get images from csv file.
        input: csv file name.
        output: list of angles and dictionary of images {left:,center:,right:}
    '''
    _csv_file = pd.read_csv(csv_file,skipinitialspace=True)
    angles,left,right,center = split_info(_csv_file)
    print('Reading images...\n')
    images = read_images([left,right,center])
    return [angles,images]
    
# ========================= Preprocess: augmentation fuctions =================
def crop(image,top_units=60):
    """ Crop images
        top_units: how many units to crop on top
    """   
    return image[top_units:,:,:]

def random_flip(image,angle,prob=0.5):
    """ Flip images with a 50% chance.
        prob: probability of flip images
    """
    if(np.random.random()<=prob): 
        return np.fliplr(image),angle*-1
    else:
        return image,angle
        
def resize(image,shape=(32,16)):
    """ Resize image for processing
    shape = (width,height)
    """
    return cv2.resize(image, shape)
    
def random_gamma(image,prob=0.5):
    """ Change brightness in a random way
        prob: probability of modified bightness
    """
    if(np.random.random()<=prob):
        gamma = np.random.uniform(0.7, 1.2) 
        return exposure.adjust_gamma(image,gamma=gamma)
    else:
        return image
    
def random_rotation(image, angle, rot_ang=9,prob=0.5):
    """ Apply small rotations on images
        prob: probability of being rotated.
        Source: https://medium.com/@ksakmann/behavioral-cloning-make-a-car-drive-like-yourself-dc6021152713#.7k8vfppvk
    """
    if(np.random.random()<=prob):
        random_angle = np.random.uniform(-rot_ang, rot_ang + 1)
        rad = (np.pi / 180.0) * random_angle
        return ndimage.rotate(image, random_angle, reshape=False), angle + (-1) * rad
    else:
        return image,angle
        
def random_shear(image, angle, shear_range=200,prob=0.8):
    """
    Source: https://medium.com/@ksakmann/behavioral-cloning-make-a-car-drive-like-yourself-dc6021152713#.7k8vfppvk
    :param image:
        Source image on which the shear operation will be applied
    :param steering_angle:
        The steering angle of the image
    :param shear_range:
        Random shear between [-shear_range, shear_range + 1] will be applied
    :return:
        The image generated by applying random shear on the source image
    """
    if (np.random.random()<=prob):
        rows, cols,ch = image.shape
        dx = np.random.randint(-shear_range, shear_range + 1)
        random_point = [cols / 2 + dx, rows / 2]
        pts1 = np.float32([[0, rows], [cols, rows], [cols / 2, rows / 2]])
        pts2 = np.float32([[0, rows], [cols, rows], random_point])
        dsteering = dx / (rows / 2) * 360 / (2 * np.pi * 25.0) / 6.0
        M = cv2.getAffineTransform(pts1, pts2)
        image = cv2.warpAffine(image, M, (cols, rows), borderMode=1)
        angle += dsteering
        return image, angle
    else:
        return image, angle
        
def transform_image(image,angle,input_size=(32,16)):
    """ Process images with different transformations, such as flip
        and rotation and shearing.
        input_size: (width,height) for resize function
    """

    image = random_gamma(image)
    image,angle = random_shear(image,angle)
    image = cv2.cvtColor(image, cv2.COLOR_RGB2HSV)[55:,:,1]
    image = resize(image,input_size)
    image,angle = random_flip(image,angle)
    image,angle = random_rotation(image,angle)
    
    return image,angle
    
#======================= Model training functions ============================= 
def save_model(model):
    """ Save Keras model
    """
    json_string = model.to_json()
    with open('model.json', 'w') as jsonfile:
        json.dump(json_string, jsonfile)
    print("Model Saved")

    
def plot_prediction(model,X_val,y_val):
    ''' Plot regression againts testing set
    '''
    # run predictions
    P = model.predict(X_val[:])
    print(P.shape)
    P = P.reshape((P.shape[0],)) 
    
    ## plot predictions over ideal behaviour (line of equality)
    import matplotlib.pyplot as plt

    fig = plt.figure(1, figsize=(5,5))
    fig.clf()
    ax = fig.add_subplot(111)
    plt.plot([-0.5,0.5],[-0.5,0.5], 'k--', label="ideal model behaviour")
    ax.scatter(P, y_val, marker='o', color="orchid", s=70, zorder=10)
    plt.xlabel("angle predicted")
    plt.ylabel("true angle")
    plt.legend(loc='best')
    plt.tight_layout()
    plt.draw()
    plt.show()
    
